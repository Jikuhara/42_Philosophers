# Philosophers
## 課題概要
「食事する哲学者問題」を解く。
主に並行・並列処理を学ぶ。

## 課題の目的
- スレッドとミューテックスを使用して、哲学者の食事問題を解決する。
- プロセスとセマフォを使用して、同様の問題を解決する（ボーナス部分）。
- 昔は、スレッドとセマフォを使用していた時期もあったらしい。

## 課題の説明
### 概要
- 哲学者は円卓に座り、スパゲッティのボウルを共有する。
- 哲学者は「食事」「思考」「睡眠」の3つの状態を繰り返す。
- 各状態は排他的で、食事中は他の状態に移行しない。
- テーブルには哲学者の数と同じ数のフォークがあり、スパゲッティを食べるには左右両方のフォークが必要。
- 哲学者は他の哲学者と会話できず、彼らの状態を知らない。
- 哲学者は餓死してはいけない。

とりあえず、一旦の全体像を把握したいなぁ。

## やること
- []入力部分の実装
- 出力部分の実装
- 使用する関数の理解

### 入力部分の実装
ここは簡単。
Atoiで整数に変換して代入する。
argc == 6の場合だけ、最後の食べた回数カウントを導入する。
それ以外の場合は食べた回数カウントIntMaxで良いかもね。


## 使用する関数の理解
1フォークを1mutexに対応させる。
1philoを1threadに対応させる。

[IBM mutex](https://www.ibm.com/docs/ja/aix/7.2.0?topic=p-pthread-mutex-init-pthread-mutex-destroy-subroutine)

thread配列と、mutex配列を用意して、そこを人数分初期化するのが最初にやるべきことかなぁ。
→人数がわからんから、可変長で用意しなあかんかぁ。面倒くさいなぁ。

Threadに対する処理を関数にしておいて、Whileで一斉に発火させるのが良さそう。
各ThreadがアクセスできるMutexはx - 1, xかな。
それぞれにアクセス出来ない場合はThinkingを続ける。
常時アクセスを試すとかは無理そうかなぁ。

最小公倍数のタイミングでアクセスを試みる、かな。

Thinking -> eating -> sleepingの順番で状態を変化させる。

thinlingの状態で、最小公倍数のアクセスタイミングが来たときに両隣のMutexを確認して、
空いている場合のみEatingに移行する。
Eatingで、規定の時間を経過したら、Sleepingに移行する。
Sleepingで、規定の時間を経過したら、Thinkingに移行する。

結局、互いに素な時間が来たら最小公倍数1やから、毎秒アクセスするし、どのみち常時アクセスにせなあかんか。


[mutex参考サイト](https://qiita.com/ryo_manba/items/e48faf2ba84f9e5d31c8)
[mutex だえう](https://daeudaeu.com/c_mutex/)

時間の概念も必要や－－ん。。
面倒くさいなぁ。。

Forkを下ろすって動作は無いんか。
やから一回持っちゃうと、両方の手にForkを持つまではずっと持ち続けるんか。
なるほど～～。

Forkを持つ = mutexをlockする
Forkを下ろす = mutexをunlockする
か。おもろい。

アクセスする = mutex_lockを呼ぶやな。
右手持つ→左手持つ→持てなかったらすぐにunlockする？
でいいのか？？？ちゃいそう。


[Thread解説 Youtube英語](https://www.youtube.com/watch?v=d9s_d28yJq0&list=PLfqABt5AS4FmuQf70psXrsMLEDQXNkLq2&ab_channel=CodeVault)
めっちゃわかりやすそう。
一旦これ見て手動かすか。
